"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const schema_utils_1 = require("schema-utils");
const loader_options_json_1 = __importDefault(require("./schemas/loader-options.json"));
const schemaOptions = loader_options_json_1.default;
const { optimize, loadConfig } = require('svgo');
const PACKAGE_NAME = require('../package.json').name;
module.exports = async function SvgChunkWebpackLoader(content) {
    const options = this.getOptions() || {};
    (0, schema_utils_1.validate)(schemaOptions, options, {
        name: 'SvgChunkWebpackPlugin Loader',
        baseDataPath: 'options'
    });
    const compiler = this._compiler;
    const callback = this.async();
    // Declare all SVG files as side effect
    // https://github.com/webpack/webpack/issues/12202#issuecomment-745537821
    this._module.factoryMeta = this._module.factoryMeta || {};
    this._module.factoryMeta.sideEffectFree = false;
    // Flag all SVG files to find them more easily on the plugin side
    this._module.buildInfo.SVG_CHUNK_WEBPACK_PLUGIN = true;
    // Check if content is a SVG file
    if (!content.includes('<svg')) {
        callback(new Error(`${PACKAGE_NAME} exception. ${content}`));
    }
    // Check if the plugin is also imported
    const plugin = compiler.options.plugins.find((plugin) => plugin.PLUGIN_NAME && plugin.PLUGIN_NAME === PACKAGE_NAME);
    if (typeof plugin === 'undefined') {
        callback(new Error(`${PACKAGE_NAME} requires the corresponding plugin`));
    }
    try {
        const { configFile } = options;
        let config;
        if (typeof configFile === 'string') {
            try {
                config = await loadConfig(configFile, this.context);
            }
            catch (error) {
                this.emitError(new Error(`Cannot find module ${configFile}`));
            }
        }
        else if (configFile !== false) {
            config = await loadConfig(null, this.context);
        }
        const result = await optimize(content, Object.assign({}, config));
        return callback(null, JSON.stringify(result.data));
    }
    catch (error) {
        return callback(error);
    }
};
